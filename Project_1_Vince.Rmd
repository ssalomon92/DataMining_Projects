---
output:
  html_document: default
  word_document: default
---


# Project 1
### Group Members: Vince Miller & Sebastian Salomon

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
library('MASS')
library('dplyr')
library('plyr')
library('knitr')
library('lemon')
library('tweedie')
library('kableExtra')
library('modeest')
library('ggplot2')
library('tidyr')
library('reshape')
library('egg')
library('gridExtra')
library('cowplot')
```

## 1. Busines Understanding

* Why is it important to know about claims, medication, days spent in the hospital, and readmission rates? Who is interested in this information? What decisions can be informed using such data?[10 Point]

Having a thorough understanding about claims, medication, days spent in the hospital, and readmission rates is extremely benefitial for hospital, healthcare providers, and patients. With comprehensive knowledge of the aforementioned information, health care providers can develop new care plans and strategies to reach patients before emergencies occur; thus, reducing unnessary hospitalizations. This in turn will increase the health of patients while decreasing the cost of care.

The reason for this project....

```{r echo=FALSE}
# Set working directory for 
setwd('../hospital')
## read in all the data
df.Claims_Y1 <- read.csv('Claims_Y1.csv')
df.Members_Y1 <- read.csv('Members_Y1.csv')
df.DayInHospital_Y2 <- read.csv('DayInHospital_Y2.csv')
```
## 2. Data Understanding
* Describe the type of data (scale, values, etc.) for each attribute in the files Members_Y1.csv, Claims_Y1.csv and DayInHospital_Y2.csv. [10 point]

<center> <h4>Dataset's Attribute Data Types</h4> </center>
```{r, results='asis'}
# set options for the table
options(knitr.kable.NA = '')
# get the class for each column
df.datatypeM <- data.frame(sapply(df.Members_Y1, class))
colnames(df.datatypeM) <- c('Data Class')
df.datatypeC <- data.frame(sapply(df.Claims_Y1, class))
colnames(df.datatypeC) <- c('Data Class')
df.datatypeD <- data.frame(sapply(df.DayInHospital_Y2, class))
colnames(df.datatypeD) <- c('Data Class')

# combine dataframes
df.datatype <- rbind(df.datatypeC,df.datatypeD,df.datatypeM)

# get number levels for members_y1
df.datatype['sex','# Levels'] <- toString(nlevels(df.Members_Y1$sex))
df.datatype['AgeAtFirstClaim','# Levels'] <- toString(nlevels(df.Members_Y1$AgeAtFirstClaim))
# get levels for claims_y1
df.datatype['Year','# Levels'] <- toString(nlevels(df.Claims_Y1$Year))
df.datatype['specialty','# Levels'] <- toString(nlevels(df.Claims_Y1$specialty))
df.datatype['placesvc','# Levels'] <- toString(nlevels(df.Claims_Y1$placesvc))
df.datatype['LengthOfStay','# Levels'] <- toString(nlevels(df.Claims_Y1$LengthOfStay))
df.datatype['dsfs','# Levels'] <- toString(nlevels(df.Claims_Y1$dsfs))
df.datatype['PrimaryConditionGroup','# Levels'] <- toString(nlevels(df.Claims_Y1$PrimaryConditionGroup))
df.datatype['CharlsonIndex','# Levels'] <- toString(nlevels(df.Claims_Y1$CharlsonIndex))

# get levels for members_y1
df.datatype['sex','Levels'] <- toString(levels(df.Members_Y1$sex))
df.datatype['AgeAtFirstClaim','Levels'] <- toString(levels(df.Members_Y1$AgeAtFirstClaim))
# get levels for claims_y1
df.datatype['Year','Levels'] <- toString(levels(df.Claims_Y1$Year))
df.datatype['specialty','Levels'] <- toString(levels(df.Claims_Y1$specialty))
df.datatype['placesvc','Levels'] <- toString(levels(df.Claims_Y1$placesvc))
df.datatype['LengthOfStay','Levels'] <- toString(levels(df.Claims_Y1$LengthOfStay))
df.datatype['dsfs','Levels'] <- toString(levels(df.Claims_Y1$dsfs))
df.datatype['PrimaryConditionGroup','Levels'] <- toString(levels(df.Claims_Y1$PrimaryConditionGroup))
df.datatype['CharlsonIndex','Levels'] <- toString(levels(df.Claims_Y1$CharlsonIndex))

#create html table
kable(df.datatype) %>%    
  group_rows('Claims_Y1',1,12) %>% 
  group_rows('DayInHospital_Y2',13,14) %>% 
  group_rows('Members_Y1',15,17) %>%
  kable_styling(full_width=T)
 
```

#### Discussion
The table above shows each variable in their respective dataset. A few variables such as MemberID, ProviderID, vendor, pcp are listed as integer values, but from the data dictionary we know these values should not be considered integers for analysis. These values will be converted to factors. MemberID appears in each dataset, but the column name is slightly different. We will need to remember this if we want to merge. Other integer values paydelay and DaysInHospital represent day counts. These values will be as integers. Lastly, there are many factor variables. Each factor count as well as the factors themselves are listed. A few things to note are year currently has no value considering it is the same for each row, LengthOfStay has missing values, and PrimaryConditionGroup has many factors comparatively. These are our preliminary findings when inspecting the data. I am sure there will be many to come!

* Give simple appropriate statistics (range, mode, mean, median, variance, etc.) for most important attributes in these files and describe what they mean if you find something interesting. [10 points]
<center> <h4>Summary Statistics for Integer Features</h4> </center>
```{r}
# create function for stats requested
my_stats <- function(x){
  df <- data.frame(list(range(x)[1],range(x)[2],mean(x),median(x),sd(x)))
  colnames(df) <- c('Min','Max','Mean','Median','SD')
  return(df)
}

# assumption that NA paydelay means paid on time
df.Claims_Y1$paydelay[is.na(df.Claims_Y1$paydelay)] <- 0

# calc stats
# for pay delay
int_stats <- my_stats(df.Claims_Y1$paydelay)
row.names(int_stats) <- c('Pay Delay')
# for daysinhospital Y2
int_stats2 <- my_stats(df.DayInHospital_Y2$DaysInHospital_Y2)
row.names(int_stats2) <- c('Days In Hospital Year 2')
# combine int simple stats
df.int_stats <- rbind(int_stats,int_stats2)
# output table 
kable(df.int_stats) %>%
  kable_styling(full_width=T) %>%
  group_rows('df.Claims_Y1',1,1) %>%
  group_rows('df.DayInHospital_Y2',2,2)
```

#### Discussion
The table above shows the min, max, mean, median, and standard deviation for the two integer variables found in the datasets. An assumption was made that missing values in the pay delay variable represent pay delay of 0. Inspecting the summary statistics for pay delay do not show much interesting information. The variable appears slightly skewed right. Inspecting the Days in Hospital Year 2 is slighly more interesting. The mean is very low considering the range. The standard deviation is also small. This variable appears that it is concentrated at 0. The summary statistics give some insight to these variables, but we can do better sleuthing with visualizations.

<center> <h4>Most and Least Frequent Observations for Categorical Data</h4> </center>
```{r, echo=FALSE}
options(knitr.kable.NA = 'Missing')
# function for finding highest and lowest count
most_least <- function(x){
  x <- count(x)
  df <- x[which.max(x$freq),]
  df2 <- x[which.min(x$freq),]
  cbind(df,df2)
}
# subset variables I want from claims
df.count <- select(df.Claims_Y1, 'specialty', 'placesvc', 'LengthOfStay', 'dsfs', 'PrimaryConditionGroup', 'CharlsonIndex')
most.least <- lapply(df.count, most_least)
# combind to dataframe
df.most.least.claims <- do.call(rbind,data.frame(cbind(most.least))$most.least)

# subset what i want from members
df.count <- select(df.Members_Y1, 'sex', 'AgeAtFirstClaim')
most.least <- lapply(df.count, most_least)
# combind to dataframe
df.most.least.members <- do.call(rbind,data.frame(cbind(most.least))$most.least)
# combine
df <- rbind(df.most.least.claims,df.most.least.members)

# rename
colnames(df) <- c('Variable (Max)', 'n', 'Variable (Min)', 'n1')
# fix missing
# df['LengthOfStay', 'Variable (Max)'] <- 'Missing'


#percent yo
df[1:6,'n'] <- (df[1:6,'n'] / nrow(df.Claims_Y1)) * 100
df[1:6,'n1'] <- (df[1:6,'n1'] / nrow(df.Claims_Y1)) * 100
df[7:8,'n'] <- (df[7:8,'n'] / nrow(df.Members_Y1)) * 100
df[7:8,'n1'] <- (df[7:8,'n1'] / nrow(df.Members_Y1)) * 100


# rerename
colnames(df) <- c('Variable (Max)', '%', 'Variable (Min)', '%')
#create html table
kable(df) %>%    
  group_rows('Claims_Y1',1,6) %>% 
  group_rows('Members_Y1',7,8) %>%
  kable_styling(full_width=F)

```
#### Discussion
The table above shows the max variable, max percent, min variable, and min percent for the count of each categorical variable in the datasets. 

* Visualize the most important attributes appropriately. Provide an interpretation for each graph. Explain for each attribute type why you chose the visualization. [10 points]

Below is a plot for each variable as they were found in their respective dataset. This sleuthing is necessary to understand each variable allowing an informed aproach for handling missing values, feature selection, and feature engineering.

```{r}
# create main df
# change column name
df.DayInHospital_Y2$MemberID <- df.DayInHospital_Y2$memberid
# remove column
df.DayInHospital_Y2$memberid <- NULL
# merge two of three data frames
df.main <- merge(df.DayInHospital_Y2,df.Members_Y1,by='MemberID')
df<- merge(df.Claims_Y1,df.main,by='MemberID',all.x=TRUE)
```

### Integer Variable Visualizations

```{r, echo=FALSE,results='hide',fig.keep='all',message=FALSE,error=FALSE}
# comment for distr. overlay
# the_tweed <- function(x){dtweedie(x, mu=mean(df$paydelay), phi=sd(df$paydelay)/3, power=1.1) *length(df$paydelay)*5}
ggplot(data=df, aes(x=paydelay)) +
  geom_histogram(binwidth=5) +
  labs(y='Count', x='Pay Delay' , title='Pay Delay Distribution') 
```


#### Discussion
The pay delay distribtuion is a zero inflated outcome. This is in part due to our assumption that missing values represent people who paid on time. It should be noted that the mean pay delay given a pay delay appears to be 30 days. This could be due to a 30 day  notice. This could be useful for hospitals. What if a simple reminder at 15 months shifted the disrtibution left. This could help hospitals understand if their customers are forgetful or are deliberlately waiting a month to pay.

```{r}
ggplot(data=df.DayInHospital_Y2, aes(x=DaysInHospital_Y2)) +
  geom_histogram(binwidth=3) +
  labs(y='Count', x='Days in the Hospital Year 2' , title='Days in the Hospital Year 2 Distribution') 
```


#### Discussion
This variable has alot of concentration at zero. It is odd that there is an uptick at 15. Reading the data dictionary you will find that anything above 15 is top coded to 15.

### Categorical Variable Visualizations

```{r}
# specialty visualization
ggplot(data=df, aes(x=reorder(df$specialty,df$specialty,
                     function(x)-length(x)))) +
  geom_bar() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y='Count', x='Specialty' , title='Specialty Breakdown')  
```

#### Discussion
The bar chart above shows the breakdown of generalized specialty. This variable has great room for improvment. The categories do not appear to be consistent related to the level of specialty they show. The higher categories to the left are not specific, and I believe their broadness is the reason why their count is higher. It is possible that this could be systemic allocation, but I think if possible there would be alot value in digging deeper for the broader categories. Currently the possibilty of overlap will make this variable less imformative.

```{r}
z <- ggplot(data=df, aes(x=reorder(df$placesvc,df$placesvc,
                     function(x)-length(x)))) +
  geom_bar() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y='Count', x='Place of Service' , title='Place of Service')  

ggdraw(z)

```

#### Discussion
The place of service is similar to the specialty variable. The barplot above shows the breakdown. When we comparing office to not office there could potentially be power in this variable, but our best guess is that beyound that this variable will not be useful. Office is very broad compared to the other variables. If trimming 6 variables was advantages I would consider changing this variable to Office or Not Office.

```{r}
ggplot(data=df.Claims_Y1, aes(x = CharlsonIndex))+
  geom_bar() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y='Count', x='Charlson Index' , title='Charlson Index Breakdown')
```

#### Discussion
The Charlson Index is a measure of the particular affect that a disease has on overall illness, grouped by significance, that generalizes additional diagnoses. Scores greater than zero
are carried forward (for up to a year) in subsequent claims with a comorbidity
score of zero [1,4]. In lay terms, a higher Charlson Index implies a higher probability of 10 year mortality rate of the particular member.

The Charlson Index distribution shown above has an exponential decay trend. This means that the probability of a particular claim on having a high Charlson Index in this particular hospital is rare.

```{r}
ggplot(data=df, aes(x=LengthOfStay)) +
  geom_bar() +
  labs(y='Count', x='Length of Stay' , title='Length of Stay Breakdown') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

#### Discussion
The breakdown for length of shows a clear data quality issue. This is consistent with our breakdwon of the Claims_Y1 dataset showing ~95% of the length of stay variable is missing. Hopefully the recording of a variable for this category has significance. If we wanted to trim variables we could change this category to missing, 1 day, and greater than 1 day.

```{r}
ggplot(data=df, aes(x=reorder(df$dsfs,df$dsfs,
                     function(x)-length(x)))) +
  geom_bar() +
  labs(y='Count', x='Days Since First Claim' , title='Days Since First Claim Breakdown') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

#### Discussion
This breakdown appears to have good data quality. According to the data dictionary the variable represents days since first claim for the current claim in each year. This variable is not very intuitve, and possibly relates to annual insurance policy premiums. If this variable is highly correlated with another it could be advantageous to choose the more intuitive option.


```{r}
# plot for primary condition variable
ggplot(data=df, aes(x=reorder(df$PrimaryConditionGroup, df$PrimaryConditionGroup,
                     function(x)-length(x)))) +
  geom_bar() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size=7)) +
  labs(y='Count', x='Pirmary Condition Group' , title='Primary Condition Group Breakdown')  
```

#### Discussion
The primary condition group does not appear to show anything extremely interesting other than some groups are more popular than others.


```{r}
# plot for primary condition variable
ggplot(data=df.Members_Y1, aes(x=reorder(AgeAtFirstClaim, AgeAtFirstClaim,
                     function(x)-length(x)))) +
  geom_bar() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y='Count', x='Age at First Claim' , title='Age at First Claim Breakdown') 
```


#### Discussion
The breakdown above shows the age at first claim. The largest group of age at first claim is 70-79 group. There is alot that do not have their first claim until they are over 80. That is great! 20-29 is the group that has the least first claims. What a time to be alive!

```{r}
ggplot(data=df.Members_Y1, aes(x = sex))+
  geom_bar() +
  theme(axis.text.x = element_text(hjust = 1)) +
  labs(y='Count', x='Gender' , title='Gender Breakdown') 
```

#### Discussion

The gender breakdown above shows a slightly lopsided breakdown in favor of the females. That means that there were more females than males with a memberID. It is also important to take account the amount of claims made from each individual, and by doing some data mapping we found that females in average made 8.925 claims per individual. In turn males in average filed 7.63 claims per individual. That means that the claims breakdown by males to females is a little more lopsided than the one shown above.

* Explore relationships between attributes: Look a the attributes and then use cross-tabulation, correlation, group-wize averages, etc. as appropriate. [10 points]

Our initial approach is to view relationships between variables that have confirmed high quality above. Visualizing the relationships between the high quality varibles can be insightful for comparing while we attempt to handle fixing data quality issues. Relationships between variables that contain data quality issues can be viewed after they are adjusted in the next section.


```{r}
# create plot
ggplot(data=df.Members_Y1, aes(AgeAtFirstClaim,fill=sex)) +
  geom_bar(position='fill') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y='Count', x='Age at First Claim' , title='Age at First Claim Breakdown') 
  
```

#### Discussion
The plot above shows shows that the distribution of sex across the age at first claim is near the expected value. This helps the assumption that there was randoming sampling as related to age at first claim and sex from the members dataset. If the members data set had very different distribution of sex across age at first claim we could suspect bad sampling methods.


```{r}
# create plot
ggplot(data=df, aes(CharlsonIndex,fill=sex)) +
  geom_bar(position='dodge') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y='Count', x='Charlson Index' , title='Charlson Index for Claims by Sex') 
```

#### Discussion
This plot is interesting because while we know there are more females, and we've stated that on average females have more claims per individual we can clearly see that the proportion of males and females in each Charlson Index is not normal. Females appear to claim less severe incidents as reported by the Charlson Index. Investigating the distributions for days spent in the hospital during year 2 for male and female show slightly different distributions. The table below shows that females have a slightly higher mean for days spent in the hospital than males. This is interesting give our knowledge of the severity of their claims. This prior imformation could 
<center> <h6>Days Spend In the Hospital in Year 2</h6> </center>
```{r, echo=FALSE}
# create gender compare variable
# make means table
df.gendercompare <- merge(df.Members_Y1,df.DayInHospital_Y2,by='MemberID')
a <- mean(df.gendercompare[which(df.gendercompare$sex=='F'), "DaysInHospital_Y2"])
b <- mean(df.gendercompare[which(df.gendercompare$sex=='M'), "DaysInHospital_Y2"])
means <- data.frame(a,b)
colnames(means) <- c('Female', 'Male')
row.names(means) <- 'Mean'
kable(means) %>%
  kable_styling(full_width=F)
```


```{r, echo=FALSE}
z <- ggplot(data=df, aes(x=reorder(df$placesvc,df$placesvc,
                     function(x)-length(x)))) +
  geom_bar() +
  theme(axis.text.x = element_blank(),axis.title.x.bottom=element_blank(),axis.title.x.top=element_blank(), axis.text.y = element_blank(), axis.title.y.left=element_blank()) +
  labs(y='Count', x='Place of Service')  




a <- ggplot(data=df, aes(x=specialty,y=specialty)) +
      geom_count() +
      theme(axis.text.x = element_blank(),axis.text.y=element_text(size=6,angle=45),axis.title.y.left=element_text(size=12),legend.position='none') +
      labs(y='Specialty', x='Place of Service') 
     

b <- ggplot(data=df, aes(y=specialty,x=dsfs)) +
      geom_count() +
      theme(axis.title.y=element_blank(),axis.title.x.bottom=element_blank(),axis.text.x.bottom=element_blank(),axis.text.y=element_blank(),legend.position='none') +
      labs(x='dsfs') 
      
c <- ggplot(data=df, aes(y=specialty,x=AgeAtFirstClaim)) +
      geom_count() +
      scale_y_discrete(position='right') +
      theme(axis.title.y=element_blank(),axis.text.x=element_blank(),axis.title.x.bottom=element_blank(),axis.text.y.left=element_blank(),axis.text.y.right=element_text(angle=45,size=6),legend.position='none') +
      labs(x='Age at first claim') 

```
<center> <h5>Joint Distributions of Categorical Variables</h5> </center>
<center>
```{r, echo=FALSE}
m <- ggplot(data=df, aes(x=reorder(df$dsfs,df$dsfs,
                     function(x)-length(x)))) +
  geom_bar() +
  theme(axis.title.y=element_blank(),axis.title.x.bottom=element_blank(), axis.text.x = element_blank(),axis.text.y=element_blank(),legend.position='none') +
      labs(x='dsfs') 




n <- ggplot(data=df, aes(x=specialty,y=factor(dsfs,levels=c("0- 1 month"  , "1- 2 months" ,"2- 3 months",  "3- 4 months" , "4- 5 months",  "5- 6 months" ,"6- 7 months" , "7- 8 months"  ,"8- 9 months" , "9-10 months","10-11 months" ,"11-12 months" )))) +
      geom_count() +
      theme(axis.title.x.top=element_text(),axis.title.x.bottom=element_blank(),axis.text.x= element_blank(),axis.text.y=element_text(size=6,angle=45),axis.title.y.left=element_text(size=7),legend.position='none') +
      labs(y='Days Since First Service', x='Place of Service') 
     

o <- ggplot(data=df, aes(y=specialty,x=dsfs)) +
      geom_count() +
      theme(axis.title.y=element_blank(),axis.title.x.bottom=element_blank(), axis.text.x = element_blank(),axis.text.y=element_blank(),legend.position='none') +
      labs(x='dsfs') 
      
p <- ggplot(data=df, aes(y=dsfs,x=AgeAtFirstClaim)) +
      geom_count() +
      scale_y_discrete(position='right') +
      theme(axis.title.y=element_blank(),axis.text.x=element_blank(),axis.title.x.bottom=element_blank(),axis.text.y.left=element_blank(),axis.text.y.right=element_blank(),legend.position='none') +
      labs(x='Age at first claim') 

#last three
q <- ggplot(data=df, aes(x=reorder(df$AgeAtFirstClaim,df$AgeAtFirstClaim,
                     function(x)-length(x)))) +
  geom_bar() +
  theme(axis.title.y=element_blank(),axis.title.x.bottom=element_text(size=6), axis.text.x = element_text(size=6,angle=45),axis.text.y=element_blank(),legend.position='none') +
      labs(x='Age at First Claim') 




r <- ggplot(data=df, aes(x=specialty,y=AgeAtFirstClaim)) +
      geom_count() +
      theme(axis.title.x.bottom=element_text(size=6),axis.text.x.bottom=element_text(size=6,angle=45),axis.text.y=element_text(size=6,angle=45),axis.title.y.left=element_text(size=7),legend.position='none') +
      labs(y='Age At First Claim', x='Specialty') 
     

s <- ggplot(data=df, aes(y=AgeAtFirstClaim,x=factor(dsfs,levels=c("0- 1 month"  , "1- 2 months" ,"2- 3 months",  "3- 4 months" , "4- 5 months",  "5- 6 months" ,"6- 7 months" , "7- 8 months"  ,"8- 9 months" , "9-10 months","10-11 months" ,"11-12 months" )))) +
      geom_count() +
      theme(axis.title.y=element_blank(),axis.title.x.bottom=element_text(size=6), axis.text.x = element_text(size=6,angle=45),axis.text.y=element_blank(),legend.position='none') +
      labs(x='Days Since First Service') 
      
t <- ggplot(data=df, aes(y=dsfs,x=AgeAtFirstClaim)) +
      geom_blank() +
      theme(axis.title.y=element_blank(),axis.text.x=element_blank(),axis.title.x.bottom=element_blank(),axis.text.y.left=element_blank(),axis.text.y.right=element_blank(),legend.position='none',axis.ticks=element_blank(),axis.line=element_blank())
      # geom_count() +
      # scale_y_discrete(position='right') +
      # theme(axis.title.y=element_blank(),axis.text.x=element_blank(),axis.title.x.bottom=element_blank(),axis.text.y.left=element_blank(),axis.text.y.right=element_blank(),legend.position='none') +
      # labs(x='Age at first claim') 
      # 

   

ggarrange(n, t, r, s, ncol=2, padding=FALSE)
```
</center>

#### Discussion
The charts above show interactions between specialty, days since first service, and age at first claim. (not finished)

```{r ,echo=FALSE}
library(sqldf)

only_1_claim<-
  sqldf("
        select df.*, count(MemberID) as count1
        from df
        group by MemberID"  )

only_f<-
  sqldf("
        select only_1_claim.*
        from only_1_claim
        where count1 = 1  ")#and CharlsonIndex != 0")

ggplot(data=only_f, aes(AgeAtFirstClaim,fill=CharlsonIndex)) +
  geom_bar(position='fill') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y='Count', x='Age' , title='Age when Claim was made Breakdown')
  
```

###Discussion:
This plot is interesting because in this one we get roughly the age of the individual. The way this
was done was by manipulating the data in order to get only the individuals that have made one claim,
therefore the age of their first claim is the same age that they had when they filed that particular
claim. By looking at the plot we can notice a positive correlation between the Charleson Index and
the age of the individual. What this means is that if you are getting a young and an old individual
filing a claim, the older individual is in average more likely to have a higher Charlson Index

```{r, echo=FALSE}
ggplot(data=df, aes(CharlsonIndex, paydelay)) +
  geom_boxplot() + #position='fill') +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(y='Pay Delay (days)', x='Charlson Index', title='Box Plots of Pay Delay by Charlson Index')
```


###Discussion:
This box plot shows us the distribution of each of the 4 different Charlson Index with respect to the
pay delay. I was orginially expecting to be more delay on the higher indexes, but the graph shows
each of the medians to be very similar between each other. The distribution also tells us that there
are more people who pay later than right away since the the upper quartile is bigger than the 1st
quartile.

* Verigy data quality: Are there missing values? Duplicate Data? Outliers? Are those mistakes? How can these be fixed? [10 points]

#### Discussion
When that datasets were first read an analysis of the key values was performed. It was found that df.Members & df.DayInHospital_Y2 shared exactly the same unique values for memberID. Also, when compared with the unique values of df.Claims_Y1 the memberid was exactly the same. These checks were necessary to ensure no data was lost during merging.

```{r, echo=FALSE}
# code for checking the key value quality
checker <- sum(sort(unique(df.Members_Y1$MemberID)) == sort(unique(df.Claims_Y1$MemberID)) &  sort(unique(df.Claims_Y1$MemberID)) == sort(unique(df.DayInHospital_Y2$MemberID)))
```

Next, an analysis of ther percent missing was performed

<center> <h4>Missing Value Table</h4> </center>
```{r, echo=FALSE}
# Set working directory for 
setwd('../hospital')
## read in table since I previously fixed pay delay missing for chart
df.Claims_Y1 <- read.csv('Claims_Y1.csv')

# pct missing
df.miss = data.frame()
# function for calculating is.na()
nap <- function(name,df){
  sum(is.na(df[[name]])) / nrow(df)
  
}

# convert empty to string to missing because we found from the 
is.na(df.Claims_Y1$LengthOfStay) <- df.Claims_Y1$LengthOfStay==''

# create dataframe of missing for claims
df.missClaims <- data.frame(sapply(names(df.Claims_Y1), nap, df=df.Claims_Y1))
df.missMembers <- data.frame(sapply(names(df.Members_Y1), nap, df=df.Members_Y1))
df.missDays <- data.frame(sapply(names(df.DayInHospital_Y2), nap, df=df.DayInHospital_Y2))

# make the names the same
df.missClaims$Percent_Missing <- df.missClaims$sapply.names.df.Claims_Y1...nap..df...df.Claims_Y1. * 100
df.missMembers$Percent_Missing <- df.missMembers$sapply.names.df.Members_Y1...nap..df...df.Members_Y1. * 100
df.missDays$Percent_Missing <- df.missDays$sapply.names.df.DayInHospital_Y2...nap..df...df.DayInHospital_Y2. * 100

# remove unwanted
df.missClaims$sapply.names.df.Claims_Y1...nap..df...df.Claims_Y1. <- NULL
df.missMembers$sapply.names.df.Members_Y1...nap..df...df.Members_Y1.<- NULL
df.missDays$sapply.names.df.DayInHospital_Y2...nap..df...df.DayInHospital_Y2. <- NULL

# bind together
df.miss <- rbind(df.missClaims, df.missMembers, df.missDays)

# round the variables
df.miss$Percent_Missing <- data.frame(apply(df.miss, 1, FUN=round, digits=2))[,1]

#create html table
kable(df.miss) %>%    
  group_rows('Claims_Y1',1,12) %>% 
  group_rows('Members_Y1',13,15) %>% 
  group_rows('DayInHospital_Y2',16,17) %>%
  kable_styling(full_width=T)

```

#### Discussion
The data quality for the dataset is not bad. The daysinhospital_Y2 and Members_Y1 dataset has no missing values. The claims_y1 has some missing values. Pay delay has ~7 percent of values missing. We mentioned earlier we will treat these as 0. We are assuming these people paid on time. Changed empty string in length of stay to missing. The Kaggle project description said that these values are suppressed therefore we will treat as missing. ProviderID, vendor, and pcp have minimal missing values. We could probably delete these observations, and move forward noting this decision in case later we want to re visit them.

An investiagtion for duplicate rows found none.

## 3. Data Preperation
